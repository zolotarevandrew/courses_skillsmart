1. Компилятор поймет и выведет ошибку. 
Изменяя название метода в базовом классе - неявно изменяем интерфейс взаимодействия. 
Если, например, делать такое изменение в библиотеке - то последствия будут максимально неприятными для ее клиентов.
Поэтому важно поддерживать обратную совместимость, помечая старый метод Obsolete и просто добавить новый makeGenericSound. 

2. Компилятор поймет и выведет ошибку.
makeSound с параметром @Override - нет такого метода в базовом классе.
Вызов Animal.makeSound с параметром невозможен - метод не определен в контракте.

3. Компилятор поймет и выведет ошибку.
Map result будет недоступно в следующем блоке try.

Здесь множество проблем:
- Если мы заранее не знаем какой конфиг придет на вход, то пытаясь достать ключ name, 
очень велика вероятность просто упасть с ошибкой.
- При получении prettyJson и последующих сравнениях с базовой строкой, могут быть неочевидные отличия.
- Ловим только IOException, хотя велика вероятность и других ошибок, тогда уж лучше не ловить ничего, или ловить 1 раз
общий Exception с понятным выводом для пользователя.

Такие конфиги лучше оборачивать в типизированные контракты, принимающие на вход jsonString, например - Config<Person>.
Работать со словарями может быть удобно для динамической обработки любых данных, но не с типизированными по своей сути контрактами.