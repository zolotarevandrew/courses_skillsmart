1) Функция получения id подписанта и его персоны.

До - кидаем exception, если персона не найдена.

После - требуем чтобы personId был не nullable, оборачиваем логику получения типов временной персоны
и регистратора в интерфейс онбординга, поскольку абстракция протекла в сервис подписания, не зависящий от онбординга.

2) Функция получения сессии вопросов.

До - если сессия не найдена или закончена, кидает http web exception..

После - заводим тип активная сессия вопросов, которая существует только если сессия активна,
возвращаем nullable объект, говоря клиенту, чтобы он сам решал, что делать с неактивной сессией.

3) Мануальное выполнение шага онбординга.

До - явно проверяем наличие CandidateSteps + User, кидая exception.
После - добавляем обязательный конструктор типа.

4) Флоу машина онбординга - обертка над движком.

До - кидаем exception, если пришли на тот же самый шаг, что и текущий.

После - не разрешаем в целом такое поведение, шаги должны быть уникальны,
если создаются копии, нужно инкапсулировать множественную логику внутри одного шага.
Инвариант перенесем внутрь stepTransitionMachine, запрещая такое поведение через реализацию 
библиотеки stateless.

5) Downgrade аккаунта - обработчик камунды.

До - злоупотребление exception-ами для обязательных параметров.

После - заводим явный метод, требующий наличия Guid входного параметра 
+ требуем обязательность онбординга - через явный отдельный метод интерфейса.

Итого - в очередной раз убеждаюсь, что грамотная система типов решает кучу проблем.
А исключительные ситуации, исходя из самого определения, стоит использовать в основном
для исключительных ситуаций:
- проверка инвариантов;
- взаимодействие с ОС/внешними системами (они ими кишат);
- другого выхода просто нет;
