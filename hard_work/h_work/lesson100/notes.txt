1) Использование CancellationToken по умолчанию — хорошо, поскольку позволяет отменить операцию при необходимости.
Большинство клиентов не нуждаются в отмене, они просто ожидают результат и не хочется усложнять вызов лишним параметром.
Однако, если отмена операции обязательна (например, при работе с HttpClient), дефолтный параметр не подходит 
— это перекладывает ответственность на клиента и может нарушить ожидаемое поведение.

2) Функция обработки текущего шага с дефолтным параметром step = Dashboard (куда происходит редирект после обработки) — хорошо.
Реальное поведение по-умолчанию.

3) Функция изменения имени с необязательной датой изменения — плохо.
- невозможно стабильно проверить логику изменения по дате;
- нарушается инкапсуляция — непонятно, кто именно установил дату, клиент или метод;

Если дата не важна, а затем всё равно проставляется по умолчанию, значит она на самом деле обязательна.
Компилятор не позволит передавать UtcNow по-умолчанию, проще сделать параметр обязательным.

4) Функция изменения адреса с множеством дефолтных параметров — плохой подход.
- непонятно, какие поля обязательны, а какие — нет;
- легко перепутать и передать значения с нарушенным порядком;
- сложно тестировать и поддерживать (множество возможных комбинаций);
- при добавлении нового поля нужно менять сигнатуру метода (условное нарушение OCP).

Варианты улучшения:
- либо создать отдельную сущность Address с Option<>-параметрами, чтобы явно указать необязательные поля;
- либо создать тип AddressField, оборачивающий строку и тип параметра (AddressFieldType), передавая IEnumerable.

Итого - дефолтные параметры скорее усложняют логику и позволяют «лепить костыли», например, через bool флаги, увеличивая цикломатическую сложность.
Необязательность лучше выражать через фп подходы, (минуя null проверки) по типу option, maybe(oneof).
Даже в редких случаях, когда необязательный параметр всего лишь один, проще сделать два отдельных конструктора класса или два метода.
Посмотрю на библиотеку LanguageExt, которую увидел в недавнем посте:)