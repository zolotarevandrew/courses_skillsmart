1) Преонбординг — мало универсальности

Преонбординг — это путь от регистрации клиента до основного онбординга, набор экранов для сбора первичной информации.

Изначально реализовано было в виде одного класса OnboardingStateService.GetState(), 
с вложенными и сложными if-ами, без выделения абстракций.

Проблемы:
- Нет тестов.
- Состояние не сохранялось, а вычислялось "на лету" — через серию HTTP-запросов к другим сервисам.
- Тяжело вносить изменения и добавлять новую логику, производительность страдала;
- Фронт обращался только через GET-запросы, вызывая цепочку действий, которые невозможно было контролировать.

Улучшения:
- Добавили сущности в базу: preonboarding и preonboarding_param для хранения состояния экранов и общего состояния преонбординга.
Выделили абстракции: PreonboardingParam и PreonboardingState.
- Теперь проще написать тесты, поскольку можно проверить каждый параметр и состояние отдельно.
- Снизили нагрузку с внешних сервисов за счёт локального кэширования параметров в preonboarding_param.
- Добавили отдельные POST-ручки, чтобы фронт не обращался в сторонние сервисы напрямую. 
Теперь он присылает параметры нам, а мы сами сохраняем их и пересчитываем состояние.

2) Сохранение данных по компании - маловато универсальности

Для изменения данных компании требуется:
- открыть транзакцию вручную, поработать с репозиториями, сохранить в них изменения;
- вручную записать аудит через события в RabbitMq + записать последние значения аудита в базу. 

Проблемы:
- В каждом месте необходимо явно открывать и передавать транзакцию при работе с репозиториями.
- Дублирование кода и трата времени на рутинную и простую операцию.
- Ручное написание sql update-ов в репозиториях сильно усложняет разработку.

Улучшения - переходим на EF core
- Разработчики смогут изменять объекты напрямую без необходимости писать SQL-код или вручную вызывать репозитории для операций обновления.
- Реализуем собственную обертку по типу (Unit of Work), скрывающую работу с транзакциями и EF Core.
- Используем стандартные возможности EF Core для аудита.

Значительно упрощаем и ускоряем процесс разработки — все рутинные действия инкапсулированы и больше не требуют дублирования кода.

3) Словари в базе данных — много универсальности

В отдельном микросервисе была реализована таблица - companydatadictionaries(id, entity, countries, isdefault, translates, metadata, ord, state)
Словари можно было запрашивать через HTTP, но данные не кэшировались внутри микросервиса.

Проблемы:
- Для добавления или изменения элементов словаря приходится добавлять миграции базы данных;
- Поля Include и Exclude иногда используется не по назначению, усложняя разработку;
- Каждый запрос обращается к базе данных, что могло создавать ненужную нагрузку, особенно если клиенты не кэшировали данные локально.

Улучшения: 
- Перешли на хранение словарей в виде отдельных JSON-файлов;
- Lazy-загрузка: словари загружаются в память при первом запросе в конкретном поде;
- Можно добавлять или изменять словари без необходимости выполнять миграции базы данных. Достаточно обновить JSON-файл.
Дополнительно можно сохранять предыдущие версии файлов в репозиторий - для истории.
- Данные загружаются из файлов и кэшируются в памяти, не создаем лишнюю нагрузки на БД.

4) ServiceMesh — много универсальности
Базовый интерфейс IServiceMesh для взаимодействия с любым внутренним микросервисом.

Проблемы:
- "божественный объект" — нарушение принципа единственной ответственности (SRP);
- трудности поддержки и рефакторинга — можно вызывать везде любой метод любого сервиса, 
и вызовы/контракты будут разбросаны по проекту;
- сложно тестировать и добавлять cross-cutting concerns (ретраев, логирования) на конкретный вызов;

Улучшения:
- создаём сервисы IMicroserviceClient с конкретными контрактами и методами, вызывая IServiceMesh внутри;
- создаём базовый класс BaseServiceMeshClient как основу реализации для вызова часто используемых методов GET/POST.

Итого 
Обычно я предпочитаю начинать с простых абстракций, которые покрывают основные кейсы,
не превращая решение в "божественную сущность", призванную решать все возможные проблемы.
        
В любом случае мы не знаем, в каком направлении будет развиваться бизнес, а можем только предполагать.
Со временем формируется экспертиза проекта и сильные, действительно универсальные абстракции рождаются либо сами собой, либо после нескольких итераций рефакторинга.
        
Стремление к излишней универсальности часто приводит к тому, что абстракция начинает решать "всё задачи".
Это увеличивает цикломатическую сложность, повышает когнитивную нагрузку и усложняет поддержку проекта.
 

