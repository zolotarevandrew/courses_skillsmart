1) Имеем толстый контроллер в рамках сущности "Контрагент".
Внутри него вызывается типичный репозиторий с кучей методов.
Сразу хочется сказать, что всё это очень просто для понимания и поддержки.

Однако, задумавшись о введении ряда абстракций, начинаешь сходить с ума, особенно если реализовать следующее:
- Заводим DTO, отделяя контекст HTTP-запроса от бизнес-логики — снижаем связность;
- Создаём Query-объект на уровне бизнес-логики — снова снижаем связность и преобразуем DTO в Query;
- Реализуем конкретный IQueryHandler — у нас же общий "мета"-интерфейс;
- Добавляем в репозиторий новый метод и вызываем его из IQueryHandler — и опять приходим к нарушению ISP.
Либо — заводим ещё один интерфейс, чтобы соответствовать DIP и ISP, ведь мы не должны знать лишнего об имплементации хранилища. :)

В итоге — сильный Indirection, а потом ещё нужно написать "тесты" — при том, что на деле мы просто делаем один тупой запрос в базу и отдаём его в HTTP API.

Для меня идеальным выглядит следующий вариант:
- Используем Minimal API, где на каждый HTTP-метод есть свой конкретный обработчик. Так проще искать по названию;
- Заводим абстрактный класс HttpQuery, который находится в API-слое, чтобы иметь доступ к инфраструктуре (например, EF или http клиентам).
- Реализуем логику прямо в наследнике от HttpQuery — делаем всё, что нужно с базой и другой логикой. Это в любом случае будет интеграционный слой..

Таким образом, мы упрощаем понимание системы. Тесты делаем интеграционные — unit-тесты здесь бесполезны.
Разве что можно выделить небольшие чистые методы (например, конвертацию данных) и покрыть их unit-тестами — этого будет достаточно.

Это будет справедливо для простых случаев (вызвать стороннее api или выдать view из базы, без какой-либо лишней обработки и переиспользования). 
Зачем усложнять жизнь себе и другим разработчикам :)

2) Имеем "толстый" контроллер в рамках сущности "Заявка на пропуск":
- В нём напрямую извлекается и используется команда (GetCommand<CreateStatementCommandHandler>), раскрываются детали реализации;
- Внутри команды вызывается IStatementDomainService, который, в свою очередь, обращается к "толстому" репозиторию — indirection;
Команда уже сама по себе является доменной, относящейся к бизнес-логике;
- Команда содержит внутри себя DTO;

Плотно повозился с co/contr variance в .NET, удалось реализовать:
- ICommandHandler<DomainCommand> регистрируется в DI по ключу, соответствующему конкретному типу команды (избавляемся от dynamic);
- Появляется возможность "диспатчить" команды в "рантайме" на основе их реального типа;
- Можно добавлять middleware для логирования и других cross-cutting concerns;
- Реализовал общий контроллер, способный обрабатывать любые DomainCommand.

Итого переделываем, следующим образом:
- Реализуем конкретную команду;
- Создаём Minimal API Controller, унаследованный от CommandController, для вызова этой команды;
- Внутри контроллера реализуем логику вызова команды, используя текущий HttpContext и параметры.

IStatementDomainService можно убрать — достаточно использовать напрямую уже существующий IStatementRepository : IRepository<Statement>.
Чтобы интерфейс не был "заголовочным", можно выделить отдельные интерфейсы IStatementCreator и т п.

Дополнительно, чтобы скрыть зависимость от IServiceProvider, можно создать ICommandSender.
Таким образом не будет протекать абстракция обработки команды, сейчас видна деталь реализации - keyed service provider,
которую лучше скрыть.

3) Имеем "толстый" контроллер в рамках сущности "Словарь":
В нём напрямую извлекается и используется команда (GetQuery<GetDictListQueryHandler>), раскрывая детали реализации;

Преимущества IQuery проявляются только в следующих случаях:
- прослеживается бизнес-логика со сложной конвертацией и зависимостями;
- требуется переиспользование обработчика в разных частях системы; 
- необходима реализация cross cutting concerns;
- когда жестко следуем ddd + cqrs;

Иначе разумнее следовать моему подходу, описанному в пункте 1.

Итого переделываем, следующим образом:
- Реализуем конкретный IQueryHandler;
- Создаём Minimal API Controller, унаследованный от QueryController, для вызова конкретного Query;
- Внутри контроллера реализуем логику вызова query, используя текущий HttpContext и параметры.

Получаем все те же преимущества, что в пункте 2.

Итого:

Получилось создать абстрактную и переиспользуемую систему для работы с CQRS на любом уровне, с поддержкой middleware.
Правда, пока не уверен, дойдёт ли она до реальных проектов :)

Дополнительно — глубоко разобрался с co-/contr-variance в .NET и успешно интегрировал её с DI.

Не стоит возводить лишние "стены" в проекте. 
Нужно думать о простоте, поддерживаемости и конкретных требованиях.
Особенно при работе с generic абстракциями — у них всегда есть своя цена.
 

