

from task2 import LinkedList2, Node


# порядковый номер самого задания на курсе - 2
#
# номер задачи из задания - 2.10
#
# краткое название - Переворачивание связного списка
#
# сложность решения (O-большое) 
# временнАя - O(N) - проходимся 1 раз по всем элементам LinkedList
# пространственная - O(1) - не используем лишнюю память
#
# рефлексия по эталонному варианту решения:
# Самым простым решением оказалась смена направления указателей и соответствующая смена head,tail в конце.
# С двумя указателями делать такие операции гораздо проще, в отличии от варианта с одним указателем.
# Можно "слегка улучшить", не делая никаких манипуляций при размере списка 0 и 1.
def reverse(src: LinkedList2):
    cur = src.head
    while cur is not None:
        next = cur.next
        cur.next = cur.prev
        cur.prev = next
        cur = next

    oldHead = src.head
    src.head = src.tail
    src.tail = oldHead

    return src


# порядковый номер самого задания на курсе - 2
#
# номер задачи из задания - 2.11
#
# краткое название - Имеются ли циклы (замкнутые на себя по кругу)
#
# сложность решения (O-большое)
# временнАя - O(N) - проходимся 2 раза по всем элементам LinkedList
# пространственная - O(N) - используем 2 раза лишнюю память для visited
#
# рефлексия по эталонному варианту решения:
# Первым вариантом пришло в голову пройтись в обе стороны от head по next и от tail по prev с set visited - для обнаружения цикла.
# Если какой-то узел уже встретился, значит цикл обнаружен. В таком случае используем лишнюю память O(N).
# Была еще мысль просто проверять инвариант что cur.next != cur and cur.next.prev = cur
# но в таком случае не все кейсы покрываются, особенно в случае зацикленности в начале или конце - совсем не то, больше про валидность структуры.
# Постфактум поискал дополнительные варианты решения (своих идей не пришло более) - алгоритм флойда черепаха заяц с двумя указателями более эффективен, не использует доп. память.
def hasCycle(src: LinkedList2):
    cur = src.head
    visited = set()
    while cur is not None:
        if cur in visited:    
            return True

        visited.add(cur)
        cur = cur.next

    cur = src.tail
    visited = set()
    while cur is not None:
        if cur in visited:    
            return True

        visited.add(cur)
        cur = cur.prev

    return False