Асимптотический анализ – это метод, позволяющий оценить поведение алгоритма при больших значениях входных данных. 
Он помогает отсеять детали, не влияющие на производительность в предельном случае, и сосредоточиться на том, как затраты (по времени и памяти) 
растут с увеличением размера входа.

Time Complexity (Временная сложность):
Оценивает, сколько времени занимает выполнение алгоритма. Выражается через функцию от размера входных данных.

Space Complexity (Пространственная сложность):
Оценивает, сколько дополнительной памяти требуется алгоритму. 
Важно различать память, используемую входными данными, и дополнительную память (auxiliary space), которая нужна для работы алгоритма.


Big O - худший случай, Обеспечивает верхнюю границу времени (или памяти), 
гарантируя, что алгоритм никогда не будет работать дольше (или занимать больше памяти), чем 
для достаточно больших n. Это позволяет оценить наихудший сценарий.

Theta n - точная или ожидаемая оценка.
Если алгоритм работает в среднем или в наиболее типичном случае за время, которое асимптотически ограничено как снизу, так и сверху функцией.

Omega n - лучший случай. 
Предоставляет нижнюю границу, гарантируя, что алгоритм всегда будет работать не быстрее для достаточно больших n.


Стек и рекурсия:
Глубина рекурсии – в худшем случае может достигать 
O(n), если рекурсия линейная. 
То есть, если алгоритм делает один рекурсивный вызов за раз (например, обход списка или линейный перебор), 
максимальное потребление памяти для стека будет O(n).

Таким образом, хотя один вызов требует лишь константного пространства, общее количество вызовов (глубина стека) может давать пространственную сложность 
O(n).

Для анализа рекурсивных алгоритмов часто применяют рекурсивное дерево. Это графическое представление рекурсии, где:

Корень дерева соответствует исходному вызову.
Дети узла – рекурсивные вызовы, порождённые данным вызовом.

Ключевые моменты анализа:
- Глубина дерева:
Отражает максимальную глубину рекурсии (например, n для линейной рекурсии).

- Работа на каждом уровне:
Подсчитайте количество операций, выполняемых на уровне дерева, и суммируйте по всем уровням.

Суммарная стоимость:
- Суммарная стоимость вычисляется как сумма затрат на всех уровнях. 
Если затраты убывают или остаются примерно одинаковыми на каждом уровне, можно получить общую оценку.


LinkedList (dummy nodes)
AddInTail, InsertAfter - O(1)
Iterate - O(N)

Использовать для FIFO, LIFO, Deque когда нужен быстрый доступ на добавление элементов или когда оно не частое и не нужен доступ по индексу.
 



